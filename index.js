// Generated by LiveScript 1.3.1
(function(){
  var fs, path, _, crypto, Promise, isText, opts, OpenCC, opencc, filepath, find, overwrite, mkdirsIfNotOverwrite, pwd, fileList, dirHead, ignore, ig, originPwd, count, total;
  fs = require('fs');
  path = require('path');
  _ = require('underscore');
  crypto = require('crypto');
  Promise = require('bluebird');
  Promise.promisifyAll(fs);
  isText = require('istextorbinary').isTextSync;
  opts = require('optimist').usage('Usage: $0 --path=[dir] [--overwrite] [--config=[file]]').demand('path').alias('p', 'path').alias('o', 'overwrite').alias('c', 'config').describe('p', 'Load a directory').describe('o', 'Overwirte file\n\t(no set: copy to filecc-out directory)').describe('c', 'OpenCC config file, default: s2t.json').argv;
  OpenCC = require('opencc');
  opencc = new OpenCC(opts.config || 's2t.json');
  filepath = function(){
    return opts.path || '';
  };
  find = function(dir, dirNode){
    var readdir, files;
    readdir = dirNode.parent ? path.join(pwd, dir) : dir;
    files = ig.filter(fs.readdirSync(readdir));
    return _.each(files, function(filestr){
      var p, file, node;
      p = dirNode.parent ? path.join(dir, filestr) : filestr;
      file = fs.lstatSync(path.join(pwd, p));
      if (file.isFile()) {
        fileList.push(p);
      }
      if (file.isDirectory()) {
        node = {
          path: filestr,
          children: [],
          parent: true
        };
        dirNode.children.push(node);
        return find(p, node);
      }
    });
  };
  overwrite = function(){
    var outdir;
    if (!opts.overwrite) {
      outdir = 'filecc-out-' + new Date().getTime();
      fs.mkdirSync(path.join(pwd, outdir));
      return outdir;
    }
    return '';
  };
  mkdirsIfNotOverwrite = function(dirNode, parent){
    var md;
    if (!opts.overwrite) {
      md = function(dirNode, parent){
        return _.each(dirNode.children, function(dir){
          var p;
          p = path.join(parent, dir.path);
          fs.mkdirSync(p);
          console.log('mkdir: ' + p);
          if (dir.children.length) {
            return md(dir, p);
          }
        });
      };
      return md(dirNode, parent);
    }
  };
  pwd = './';
  pwd = path.join(pwd, filepath());
  fileList = [];
  dirHead = {
    path: pwd,
    children: []
  };
  ignore = require('ignore');
  ig = ignore().addIgnoreFile(path.join(pwd, 'fileccignore'));
  ig.addPattern(['filecc-out-*']);
  find(pwd, dirHead);
  originPwd = pwd;
  pwd = path.join(pwd, overwrite());
  mkdirsIfNotOverwrite(dirHead, pwd);
  count = total = 0;
  Promise.map(fileList, function(file){
    var ofilepath, nfilepath;
    ofilepath = path.join(originPwd, file);
    nfilepath = path.join(pwd, file);
    return fs.readFileAsync(ofilepath).then(function(data){
      var result, translateData;
      result = {
        required: false,
        data: data
      };
      if (!isText(file, data)) {
        return Promise.resolve(result);
      }
      data = data.toString('utf8');
      translateData = opencc.convertSync(data);
      if (data !== translateData) {
        result.required = true;
        result.data = translateData;
      }
      return Promise.resolve(result);
    }).then(function(result){
      total++;
      if (result.required || !opts.overwrite) {
        if (result.required) {
          count++;
        }
        console.log('writing file: ' + nfilepath + (result.required ? '(changed)' : ''));
        return fs.writeFileAsync(nfilepath, result.data);
      }
    });
  }).then(function(){
    return console.log('end (changed: %d, total: %d)', count, total);
  });
}).call(this);
