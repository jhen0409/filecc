// Generated by LiveScript 1.3.1
(function(){
  var fs, path, _, crypto, ignoreParams, Promise, OpenCC, opencc, opts, md5, filepath, find, overwrite, mkdirsIfNotOverwrite, pwd, fileList, dirHead, ignore, ig, originPwd;
  fs = require('fs');
  path = require('path');
  _ = require('underscore');
  crypto = require('crypto');
  ignoreParams = require('./ignore.json');
  Promise = require('bluebird');
  Promise.promisifyAll(fs);
  OpenCC = require('opencc');
  opencc = new OpenCC('t2s.json');
  opts = require('optimist').usage('Usage: $0 --path=[dir] [--overwrite]').demand('path').alias('p', 'path').alias('o', 'overwrite').describe('p', 'Load a directory').describe('o', 'Overwirte file\n(no set: copy to filecc-out directory)').argv;
  md5 = function(data){
    return crypto.createHash('md5').update(data).digest('hex');
  };
  filepath = function(){
    return opts.path || '';
  };
  find = function(dir, dirNode){
    var readdir, files;
    readdir = dirNode.parent ? path.join(pwd, dir) : dir;
    files = ig.filter(fs.readdirSync(readdir));
    return _.each(files, function(filestr){
      var p, file, node;
      p = dirNode.parent ? path.join(dir, filestr) : filestr;
      file = fs.lstatSync(path.join(pwd, p));
      if (file.isFile()) {
        fileList.push(p);
      }
      if (file.isDirectory()) {
        node = {
          path: filestr,
          children: [],
          parent: true
        };
        dirNode.children.push(node);
        return find(p, node);
      }
    });
  };
  overwrite = function(){
    var outdir;
    if (!opts.overwrite) {
      outdir = 'filecc-out-' + new Date().getTime();
      fs.mkdirSync(path.join(pwd, outdir));
      return outdir;
    }
    return '';
  };
  mkdirsIfNotOverwrite = function(dirNode, parent){
    var md;
    if (!opts.overwrite) {
      md = function(dirNode, parent){
        return _.each(dirNode.children, function(dir){
          var p;
          p = path.join(parent, dir.path);
          fs.mkdirSync(p);
          console.log('mkdir: ' + p);
          if (dir.children.length) {
            return md(dir, p);
          }
        });
      };
      return md(dirNode, parent);
    }
  };
  pwd = './';
  pwd = path.join(pwd, filepath());
  fileList = [];
  dirHead = {
    path: pwd,
    children: []
  };
  ignore = require('ignore');
  ig = ignore().addIgnoreFile(path.join(pwd, 'fileccignore'));
  ignoreParams.push('filecc-out-*');
  ig.addPattern(ignoreParams);
  find(pwd, dirHead);
  originPwd = pwd;
  pwd = path.join(pwd, overwrite());
  mkdirsIfNotOverwrite(dirHead, pwd);
  Promise.map(fileList, function(file){
    var ofilepath, nfilepath;
    ofilepath = path.join(originPwd, file);
    nfilepath = path.join(pwd, file);
    return fs.readFileAsync(ofilepath).then(function(data){
      var result, hash, translateData, translateHash;
      result = {
        required: false,
        data: data
      };
      if (data.toString() !== new Buffer(data.toString()).toString()) {
        return Promise.resolve(result);
      }
      data = data.toString('utf8');
      hash = md5(data);
      translateData = opencc.convertSync(data);
      translateHash = md5(translateData);
      if (hash !== translateHash) {
        result.required = true;
        result.data = translateData;
      }
      return Promise.resolve(result);
    }).then(function(result){
      if (result.required || !opts.overwrite) {
        console.log('writing file: ' + nfilepath + (result.required ? '(changed)' : ''));
        return fs.writeFileAsync(nfilepath, result.data);
      }
    });
  }).then(function(){
    return console.log('end');
  });
}).call(this);
